Here's some general ideas for this kind of problems.

Generally, the requirement wants you to return all of possible permuted numbers placed in lists. You can solve it step by step, first don't consider duplicate cases, output all of permutations with duplicates.

Usually, we use depth first search to solve it in a recursive way. For recursive calls, you wanna consider the base case first. Under which condition do you want this recursive call to end and return? In our case, it's when you put all of numbers in a list container, so the size of list needs to equals total count of numbers. First, you wanna add number elements into list one by one. Since we are going to add it recursively, we'll need to have some way to keep track of which number has been added in previous calls. There are two ways of doing it: use an index and increment that index in subsequent calls or a boolean array to cache if the element is visited or not. At each call, we wanna loop over each element within the array, if it's not been visited before, add it to your list container, mark it as visited. When backtracking, reset your previous actions.

Next, we'll work on duplicate removals. In order to do it, we'll first need to find out what causes duplicate outputs by observing example cases. For example, "1, 2, 1" will generate duplicate cases. (First, Third, Second) and (Third, First, Second) will output the same result. We can tell it is the duplicate numbers that result in the duplicate outputs. To deal with it, we will need to skip the rest and only output the first one when there are duplicate numbers. First, we group duplicate numbers together by sorting the input array. Then, starting from the second number, we check if it equals its previous, and if the previous is not visited yet(which will generate duplicate output), we skip it.
